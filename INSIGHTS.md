- Swarm project init leaves a placeholder `tasks.md`; populate it from the PRD before asking the operator for variation count.
- Keep PRDs and task lists scoped to the user request; avoid injecting the Rust CLI constraint into unrelated content tasks.
- `swarm project init projectname --with-prd` might fail if the default engine (claude) is unavailable; it falls back to the default `tasks.md` and prints a warning.
- Detect engine availability at conversation start with `codex login status` (look for `Logged in using`) and `claude -p "PRINT exactly 'CLAUDE_READY'"` (expects `CLAUDE_READY`), cache the result in `.juliet/session.md`, and only re-detect on explicit refresh/reset.
- Background `swarm run` jobs may terminate when Juliet exits; use `nohup ... &` and record the PID from `$!` so they survive after the CLI finishes.
- In `juliet next`, report completed results once per process (track with `reported_on` in `.juliet/processes.md`) even if other runs are still active, and avoid adding a needs entry until all runs finish.
- The `claude` CLI may not be here; in this case use `codex` for `swarm` engine selection (if it is available).
- Swarm logs may not emit a results path; if none is present, treat the target branch as the results location.
- The `python` binary may be missing in this environment; lean on shell tools like `awk` or `rg` for quick checks.
- Swarm-managed branch worktrees live under `.swarm-hug/.shared/worktrees/` with `/` encoded as `%2F` in directory names, which matters for scripted cleanup.
- Once results are reported and the operator responds, prune stale `Completed` entries from `.juliet/processes.md` to keep state concise; logs and branches preserve the detail.
- On boot, reconstruct intent from `.juliet/processes.md`, `.juliet/needs-from-operator.md`, and `.juliet/projects.md` before any idle greeting so Juliet resumes in-flight work reliably after restarts.
- This repo currently has no CI workflows or standard build tooling in the root (no `Cargo.toml`, `Makefile`, or `justfile`), so content-only tasks may not have automated validation commands to run.
- For this sprint’s follow-up comparison work, the sonnet sources for `feature/wind-sonnets-try1` and `feature/wind-sonnets-try2` are both in `wind-sonnets.md`; try ordering differs by theme, so a thematic crosswalk is useful before line-level scoring.
- In this environment, a practical sprint output location for reviewer discovery was `.swarm-hug/sprint-1-followups/`; if future sprint scaffolds add an explicit output directory, prefer that instead.
- Swarm project planning files are lowercase (`tasks.md`, `specs.md`) under `.swarm-hug/<project>/`; probing uppercase variants (`TASKS.md`, `SPECS.md`) can silently miss real project state.
- `git merge --autostash` can leave an `autostash` entry and mark files as staged after conflict recovery; verify `git diff --stat` matches stash contents before dropping it and restore unstaged state if needed.
- This project compiles as a single-file Rust binary without `Cargo.toml`; reusable helpers can live in sibling `*.rs` modules (via `mod ...`) and be validated with `rustc juliet.rs` plus `rustc --test juliet.rs`.
- For CLI shape changes in this repo, modeling parsing as a typed enum (`Init` vs `Launch`) plus centralized usage-string errors makes `rustc --test juliet.rs` coverage straightforward and reduces dependence on external `codex`/`claude` binaries during validation.
- For multi-role state setup, an idempotent scaffold helper that only creates missing `.juliet/<role>/` files/directories (without truncating existing state) and treats runtime `juliet-prompt.md` as launch-time output appears to fit the current specs; verify this remains true if init semantics evolve.
- For multi-role discovery, `.juliet/artifacts/` may be either legacy storage or a configured `artifacts` role; a practical discriminator is requiring the full role-state layout (`session.md`, `needs-from-operator.md`, `projects.md`, `processes.md`, plus nested `artifacts/`) before counting it as a role.
- `rustc --test juliet.rs` runs `#[cfg(test)]` modules in sibling `mod` files, so unit coverage for role helpers can stay in `role_name.rs`/`role_state.rs`; on Unix, non-UTF8 directory-entry behavior can be validated safely with `#[cfg(unix)]` tests.
- For `juliet init --role <name>`, idempotency should trigger only when both `prompts/<role>.md` and a fully scaffolded `.juliet/<role>/` layout exist; if files are missing inside an existing role directory, treat init as repair work and scaffold them.
- For `juliet init --role artifacts`, a pre-existing legacy `.juliet/artifacts/` directory plus `prompts/artifacts.md` should still be treated as repair work (scaffold missing state files) and report `Initialized role: artifacts`; otherwise implicit launch can still hit `No roles configured`.
- For init-path tests in this single-file Rust layout, asserting partial states (`prompt-only` and `state-only`) catches regressions in the "both-exist means AlreadyExists; otherwise fill gaps" contract without needing external CLI process tests.
- For explicit launch (`juliet --role <name> <engine>`), checking `.juliet/<name>/` as the role-existence gate and staging `prompts/<name>.md` into `.juliet/<name>/juliet-prompt.md` before engine execution matches the current spec; if role-config semantics change later, revisit this gate first.
- For implicit launch (`juliet <claude|codex>`), current specs appear to require role resolution strictly from `.juliet/` discovery (0 => guided init error, 1 => auto-select, >1 => explicit-role list), so legacy `prompts/juliet.md` should not be used as a runtime fallback unless requirements change.
- For explicit launch (`juliet --role <name> <engine>`), validating `<name>` with the shared role-name rules before any path joins appears necessary to prevent `../...` traversal inputs from escaping `.juliet/<role>/`; a regression test can assert the invalid-name error and no out-of-scope runtime prompt write.
- Launch parsing should treat trailing args as operator input for both `juliet --role <name> <claude|codex> ...` and `juliet <claude|codex> ...`, then append that text as `User input:` to the staged prompt immediately before engine invocation.
- For launch exit-code guarantees, a helper that runs launch flow against an injected engine runner (instead of calling binaries directly) can keep CLI behavior unchanged while making explicit and implicit engine-exit passthrough testable in `rustc --test juliet.rs`.
- For PRD-level CLI matrix checks in this single-file Rust repo, subprocess integration tests can compile `juliet.rs` once inside `#[cfg(test)]`, run the binary in temp project roots, and inject a PATH-prepended mock `codex` script to assert exact output text, staged prompt content, and exit codes without external engine dependencies.
- Multi-role docs should treat `.juliet/<role>/` directories as the source of truth for configured roles; `prompts/juliet.md` is a seed/default prompt file and should not be documented as an active role by itself.
- For new CLI commands (`reset-prompt`, `clear-history`, `exec`), follow the existing pattern: add a `CliCommand` variant, a `CliError` variant with command-specific usage, a `parse_*_command` function, and wire it into `parse_cli_command`'s match. Stub handlers in `main` unblock other agents to implement execution logic independently.
- The `exec` command has two parse paths (explicit `--role` and implicit); both must validate that a message is present after the engine arg. The message is all remaining args joined by spaces, same as operator input in launch.
- Sprint worktree naming convention: the sprint branch worktree shares a suffix with the agent worktree (e.g., both end in `-2dm6gn`). If `team-state.json` is missing, match worktrees by suffix to find the sprint branch.
- Tasks may arrive pre-implemented from earlier sprints; always verify the existing code against the spec before assuming work is needed. A round-trip integration test (init → modify → reset → compare with original) is a high-value addition when the core logic is already in place.
- When a task is marked incomplete in tasks.md but followup tasks (e.g., #16) claim it was delivered, verify the code and tests are actually present before writing new code. The six clear-history integration tests (empties state, deletes runtime prompt, clears artifacts, preserves prompt, error cases, usage) fully satisfy the #9 spec.
- For remote companion apps driving heartbeats over SSH, `.juliet/needs-from-operator.md` appears to be the most stable current attention signal; if a future `juliet status --json` contract is added, clients can avoid brittle natural-language status parsing.
- If prompt/state contracts add a new role-scoped state file under `.juliet/<role>/`, update `role_state.rs` `STATE_FILES` and clear-history/init assertions in `juliet.rs` together; otherwise behavior and tests can drift.
- For init/re-init hygiene, managing a canonical `.juliet/.gitignore` (ignore everything except `.juliet/<role>/prompt.md`) in `initialize_role` plus `create_role_state` helps keep runtime state out of commits while still tracking role prompt customizations, including repair on repeated `init`.
- `swarm run` now requires both `--source-branch` and `--target-branch` on every run: initial work should fork from the source branch to a target branch (for example `main` -> `feature/foo`), while continued work on the same branch should set both flags to that branch.
- If sprint execution should be blocked pending operator contact info, a reliable prompt pattern is: enforce `.swarm-hug/email.txt` as a pre-run prerequisite, keep a canonical email request in `.juliet/<role>/needs-from-operator.md` until resolved, and gate `swarm run` on that check.
- If operator tooling expects a `needs_from_operators` section, enforce a strict rendering contract in the prompt: use a bulleted or numbered list when needs exist, and output exactly `(none)` when there are no open needs.
- In swarm 0.5.0, run boot may fail with missing `.swarm-hug/<project>/runs/<branch>/tasks.md` when `.swarm-hug/<project>/` artifacts were not committed on the run `--source-branch`; a practical guardrail is to enforce pre-run `git ls-tree <source-branch> -- .swarm-hug/<project>/tasks.md` and commit artifacts before any `swarm run`.
- If the checked-out branch and intended run `--source-branch` diverge (for example project artifacts initialized on `main` while currently on a feature branch), Juliet should stop and ask which branch to use instead of silently committing or launching.
- CLI option migration appears simplest if `--project` is treated as canonical while `--role` remains a parser alias; keep help text explicit about the alias so usage guidance shifts without breaking existing scripts.
- Shared learnings currently fit better as `.juliet/.shared/learnings.md` than role-local files; when introducing `.juliet/.shared/`, role discovery likely needs an explicit skip for that directory to avoid false "configured role" matches.
