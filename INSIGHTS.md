- Swarm project init leaves a placeholder `tasks.md`; populate it from the PRD before asking the operator for variation count.
- Keep PRDs and task lists scoped to the user request; avoid injecting the Rust CLI constraint into unrelated content tasks.
- `swarm project init projectname --with-prd` might fail if the default engine (claude) is unavailable; it falls back to the default `tasks.md` and prints a warning.
- Detect engine availability at conversation start with `codex login status` (look for `Logged in using`) and `claude -p "PRINT exactly 'CLAUDE_READY'"` (expects `CLAUDE_READY`), cache the result in `.juliet/session.md`, and only re-detect on explicit refresh/reset.
- Background `swarm run` jobs may terminate when Juliet exits; use `tmux` sessions and record the pane PID so they survive after the CLI finishes.
- In `juliet next`, report completed results once per process (track with `reported_on` in `.juliet/processes.md`) even if other runs are still active, and avoid adding a needs entry until all runs finish.
- The `claude` CLI may not be here; in this case use `codex` for `swarm` engine selection (if it is available).
- Swarm logs may not emit a results path; if none is present, treat the target branch as the results location.
- The `python` binary may be missing in this environment; lean on shell tools like `awk` or `rg` for quick checks.
- Swarm-managed branch worktrees live under `.swarm-hug/.shared/worktrees/` with `/` encoded as `%2F` in directory names, which matters for scripted cleanup.
- Once results are reported and the operator responds, prune stale `Completed` entries from `.juliet/processes.md` to keep state concise; logs and branches preserve the detail.
- On boot, reconstruct intent from `.juliet/processes.md`, `.juliet/needs-from-operator.md`, and `.juliet/projects.md` before any idle greeting so Juliet resumes in-flight work reliably after restarts.
- This repo currently has no CI workflows or standard build tooling in the root (no `Cargo.toml`, `Makefile`, or `justfile`), so content-only tasks may not have automated validation commands to run.
- For this sprintâ€™s follow-up comparison work, the sonnet sources for `feature/wind-sonnets-try1` and `feature/wind-sonnets-try2` are both in `wind-sonnets.md`; try ordering differs by theme, so a thematic crosswalk is useful before line-level scoring.
- In this environment, a practical sprint output location for reviewer discovery was `.swarm-hug/sprint-1-followups/`; if future sprint scaffolds add an explicit output directory, prefer that instead.
- Swarm project planning files are lowercase (`tasks.md`, `specs.md`) under `.swarm-hug/<project>/`; probing uppercase variants (`TASKS.md`, `SPECS.md`) can silently miss real project state.
- `git merge --autostash` can leave an `autostash` entry and mark files as staged after conflict recovery; verify `git diff --stat` matches stash contents before dropping it and restore unstaged state if needed.
- This project compiles as a single-file Rust binary without `Cargo.toml`; reusable helpers can live in sibling `*.rs` modules (via `mod ...`) and be validated with `rustc juliet.rs` plus `rustc --test juliet.rs`.
- For CLI shape changes in this repo, modeling parsing as a typed enum (`Init` vs `Launch`) plus centralized usage-string errors makes `rustc --test juliet.rs` coverage straightforward and reduces dependence on external `codex`/`claude` binaries during validation.
- For multi-role state setup, an idempotent scaffold helper that only creates missing `.juliet/<role>/` files/directories (without truncating existing state) and treats runtime `juliet-prompt.md` as launch-time output appears to fit the current specs; verify this remains true if init semantics evolve.
- For multi-role discovery, treating `.juliet/<role>/` directories as the source of truth (while skipping non-directories, `.juliet/artifacts/`, and `.juliet/juliet`) avoids accidentally promoting legacy `prompts/juliet.md` or orphan prompt files into configured roles.
- `rustc --test juliet.rs` runs `#[cfg(test)]` modules in sibling `mod` files, so unit coverage for role helpers can stay in `role_name.rs`/`role_state.rs`; on Unix, non-UTF8 directory-entry behavior can be validated safely with `#[cfg(unix)]` tests.
- For `juliet init --role <name>`, idempotency should trigger only when both `prompts/<role>.md` and `.juliet/<role>/` already exist; if either is missing, create just the missing pieces and still report `Initialized role: <name>`.
- For init-path tests in this single-file Rust layout, asserting partial states (`prompt-only` and `state-only`) catches regressions in the "both-exist means AlreadyExists; otherwise fill gaps" contract without needing external CLI process tests.
- For explicit launch (`juliet --role <name> <engine>`), checking `.juliet/<name>/` as the role-existence gate and staging `prompts/<name>.md` into `.juliet/<name>/juliet-prompt.md` before engine execution matches the current spec; if role-config semantics change later, revisit this gate first.
- For implicit launch (`juliet <claude|codex>`), current specs appear to require role resolution strictly from `.juliet/` discovery (0 => guided init error, 1 => auto-select, >1 => explicit-role list), so legacy `prompts/juliet.md` should not be used as a runtime fallback unless requirements change.
- For explicit launch (`juliet --role <name> <engine>`), validating `<name>` with the shared role-name rules before any path joins appears necessary to prevent `../...` traversal inputs from escaping `.juliet/<role>/`; a regression test can assert the invalid-name error and no out-of-scope runtime prompt write.
- For launch exit-code guarantees, a helper that runs launch flow against an injected engine runner (instead of calling binaries directly) can keep CLI behavior unchanged while making explicit and implicit engine-exit passthrough testable in `rustc --test juliet.rs`.
